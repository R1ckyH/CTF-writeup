# RSA LCG (100 points, 146 solves)

By [`R1ckyH`](https://github.com/R1ckyH)

是咁的， LCG 真係可以pay to win

### Challenge Description

```
RSA LCG (0)
Mandela once said, "Don't generate RSA primes with insecure PRNGs". As a LCG-holic, I am not going to listen to him. What will go wrong?
```


### This is the official solution
```python
if __name__ == '__main__':
    FLAG = os.environb.get(b'FLAG', b'hkcert24{***REDACTED***}')

    seed = secrets.randbits(16) | 1
    lcg = LCG(bits=128, seed=seed)

    print(f'{lcg = }')

    ps = [get_prime(lcg, bits=1024) for _ in range(4)]
    n = reduce(mul, ps)
    e = 0x10001

    m = int.from_bytes(FLAG, 'big')
    c = pow(m, e, n)

    print(f'{n = }')
    print(f'{e = }')
    print(f'{c = }')
```


The official solution is slow, which the author say:

`Since there are only 32768 possible seeds in total, it is expected to take 2.6 hours to enumerate all of them.`

## Quick Win

```python
def main(seed):

    lcg = LCG(bits=128, a=181525535962623036141846439269075744717, c=115518761677956575882056543847720910703, seed=1)
    
    n = 481114791694785858695050549695538734046971417176843978882044871919616727765643820034066591387776993303130591599679964348353329376559922076715381691496791199317834852972956556186543750873476577029492255903246050392214315442941266567737558736141253495436298490003513325026207840446389886295321748490024615821174562383476857761918630446488869812894422048853097952363719756297344014883459670109643440173428469002028435568608888993928248402297380061528970024946401518041243564217741744613525402813984605478699738311132717493610790718032712239270654974446116711995328572373804563487208899590643981315012517538379075118546604524143430683964513429268368997878214614073305169449253802788601323508855536854500946367628892634824935231007194546528797696281628426050519984306590514055620223093615738335974270220301535497863462980632453977776013292134758089648072661829571370276168813518517058289217357255320627263734650032320305279867840420886394855960116879598125383109784504746667833173574005936871719063288584361794901458463052848937392072728849939635133710409996428462876274835371522565826839423046726308001047859782566419852401917763502007196004524754115471117969452116174478677547559057917128250716516531170082878464757039874318490906158689
    e = 65537
    c = 345977789156696385683581168846000378215844867611205467179181525756923773343997491856273352579925123046597359189866939437231366570263052567113535467666353517443555775669947203980735918360811410985879753948221470545729133552842244535778330182549296248222039054438197983267418429814674564210947108838042963108251861548375535326969960093796185009763176002544709169063466256285182205803310470811843866647483609768051301160908646352263376778439044867189801653416628219979460525679135210530110143121851284249580066642389243748128010268277263972367956550837364650977683324140767090284085773301486622501777068017859676285398384937589784505599555747372780238872296757407155242584567297352399943303106161556729208284654934208601533197169169514879515899747537955886064112109885660797961038075757520138954391314283382301755474526387505278386817416193439304304484679228240909612236945218009947246430065957288065358434877715856330476675541582153869420244176864467086961698529560004535449279996657026744930241841052475481816491735959706500890907139027990119800255632071177694111432383236909734940374926954075681464953536382583119130818187839809617068848876572944726598351264384270260481762978383770917542259594389267566490962365207501538561114532291
    # 1. Looks for the seed that generates to the prime
    lcg.seed = seed
    ps = [get_prime(lcg, bits=1024) for _ in range(4)]
    if ps[0] * ps[1] * ps[2] * ps[3] == n:
        print(ps[0], ps[1], ps[2], ps[3])

        n = ps[0] * ps[1] * ps[2] * ps[3]
        phi = (ps[0]-1) * (ps[1]-1) * (ps[2]-1) * (ps[3]-1)
        e = 0x10001
        d = pow(e, -1, phi)

        # 3. Decrypts the ciphertext
        m = pow(c, d, n)

        # 4. Converts the ciphertext to a bytearray, and prints it
        flag = long_to_bytes(m)
        print(f'{flag = }')
        exit()
    elif seed % 11 == 0:
        print(f"seed: {seed}")

if __name__ == '__main__':
    seeds = []
    for seed in range(1, 2**16, 2):
        seeds.append(seed)
    with Pool(128) as p:
        p.map(main, seeds)

```



```
Using 128 thread to speed up the speed by 128 times
```



### Improvement
To optimize the function we can spped upn with prime number

The code is here
```python
    def get_prime(lcg, bits):
        while True:
            p = 0
            for i in range(bits//lcg.bits):
                p <<= lcg.bits
                p |= lcg.next()
    
            if p.bit_length() != bits: continue
            if not is_prime(p): continue
    
            return p

    def main(seed):
    ...
    ...
    ...
    ps = [get_prime(lcg, bits=1024) for _ in range(4)]
    if ps[0] * ps[1] * ps[2] * ps[3] == n:
        print(ps[0], ps[1], ps[2], ps[3])

```

In the code here, we can find that the prime number need a large calculation

To optimize the code, we can first change the code to check the first prime is factor of n or not.

```python
    ps1 = get_prime(lcg, bits=1024)
    if n % ps1 != 0:
        return
    ps = [ps1] + [get_prime(lcg, bits=1024) for _ in range(3)]
    if ps[0] * ps[1] * ps[2] * ps[3] == n:
        print(ps[0], ps[1], ps[2], ps[3])
```

Then we can find the flag with a faster speed!
