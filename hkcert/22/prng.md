# Slow keystream (400 points, 6 solves)
# 奧牛奶公司？

By [`R1ckyH`](https://github.com/R1ckyH)

是咁的，random 真係大癲

When I open the
[zip file](https://file.hkcert22.pwnable.hk/prng_91278af07ecf105fb8c0cf9f0955514b.zip)
, I find three files, `flag`, `flag.enc`, and `flag.go`

After opening the hex of `flag`, we can find this is a start with `.ELF`
So it may be a Linux executable compiled by file `flag.go`

> Actually I just directly compile and run the `flag.go`

When I run it, I find that it uses a lot of time to print the full flag, and calculating time will **increase** after **every** new character is decoded.
Therefore, it is impossible to directly decode the `flag` with `flag.go`.
We can now focus on `flag.go`
> Part of code pick from `flag.go`
```go
    rand.Seed(1337)
    flag, err := os.ReadFile("flag.enc")
    for i, j := uint64(0), 0; j < len(flag); i++ {
        rand.Uint64()
        if i == uint64(1)<<j {
            x := byte(rand.Uint64())
            fmt.Print(string(flag[j] ^ x))
            j += 1
        }
    }
```
After viewing the code of `flag.go`, I find that the way to decode n the flag is to use the `(2^n + n)` th of `byte(rand.Uint64)` to XOR with `n` th encoded flag byte.

> We now know that the time cost of running this script is expensive because of call `rand.Uint64` for `2^64 + 64` times

### Let's take a look at source code of `rand.Uint64` and `rand. Seed`
>Code from [`src/math/rand.go`](https://go.dev/src/math/rand/rng.go)
```go
func seedrand(x int32) int32 {
    const (
        A = 48271
        Q = 44488
        R = 3399
    )

    hi := x / Q
    lo := x % Q
    x = A*lo - R*hi
    if x < 0 {
        x += int32max
    }
    return x
}

// Seed uses the provided seed value to initialize the generator to a deterministic state.
func (rng *rngSource) Seed(seed int64) {
    rng.tap = 0
    rng.feed = rngLen - rngTap

    seed = seed % int32max
    if seed < 0 {
        seed += int32max
    }
    if seed == 0 {
        seed = 89482311
    }

    x := int32(seed)
    for i := -20; i < rngLen; i++ {
        x = seedrand(x)
        if i >= 0 {
            var u int64
            u = int64(x) << 40
            x = seedrand(x)
            u ^= int64(x) << 20
            x = seedrand(x)
            u ^= int64(x)
            u ^= rngCooked[i]
            rng.vec[i] = u
        }
    }
}
func (rng *rngSource) Uint64() uint64 {
    rng.tap--
    if rng.tap < 0 {
        rng.tap += rngLen
    }

    rng.feed--
    if rng.feed < 0 {
        rng.feed += rngLen
    }

    x := rng.vec[rng.feed] + rng.vec[rng.tap]
    rng.vec[rng.feed] = x
    return uint64(x)
}
```
> We can see that the random Uint64 is generated by adding the index of `rng.vec`, and it will be initiated with calling `Seed` function by operating the constant array `rngCooked` and other constants

### Here are the source code of `rng`, `rngCooked`, and other constants
>Code from [`src/math/rand.go`](https://go.dev/src/math/rand/rng.go)
```go
const (
    rngLen   = 607
    rngTap   = 273
    rngMax   = 1 << 63
    rngMask  = rngMax - 1
    int32max = (1 << 31) - 1
)

var (
    // rngCooked used for seeding. See gen_cooked.go for details.
    rngCooked [rngLen]int64 = [...]int64{
        -4181792142133755926, -4576982950128230565, 1395769623340756751,
        .............................................................,
        8382142935188824023, 9103922860780351547, 4152330101494654406,
    }
)

type rngSource struct {
    tap  int           // index into vec
    feed int           // index into vec
    vec  [rngLen]int64 // current feedback register
}
```

Actually we don't need to know how `rand.Seed` works, we just need to take the value of `vec` after calculating the **`seed`** with `rand.Seed`

So I write a function of `golang` to calculate and display the value of `vec` with `seed` **`1337`** (given in `flag.go`) by modifying the source code of `rng.seed()`

>Code modify from [`src/math/rand.go`](https://go.dev/src/math/rand/rng.go) by [`R1ckyH`](https://github.com/R1ckyH)
```go
const (
    rngLen   = 607
    rngTap   = 273
    rngMax   = 1 << 63
    rngMask  = rngMax - 1
    int32max = (1 << 31) - 1
)


var (
    // rngCooked used for seeding. See gen_cooked.go for details.
    rngCooked [rngLen]int64 = [...]int64{
        -4181792142133755926, -4576982950128230565, 1395769623340756751,
        .............................................................,
        8382142935188824023, 9103922860780351547, 4152330101494654406,
    }
)


func seedrand(x int32) int32 {
    const (
        A = 48271
        Q = 44488
        R = 3399
    )
    hi := x / Q
    lo := x % Q
    x = A*lo - R*hi
    if x < 0 {
        x += int32max
    }
    return x
}


func RandSeed(seed int64, n int) {
    var vec [rngLen]int64

    seed = seed % int32max
    if seed < 0 {
        seed += int32max
    }
    if seed == 0 {
        seed = 89482311
    }

    x := int32(seed)
    for i := -20; i < rngLen; i++ {
        x = seedrand(x)
        if i >= 0 {
            var u int64
            u = int64(x) << 40
            x = seedrand(x)
            u ^= int64(x) << 20
            x = seedrand(x)
            u ^= int64(x)
            u ^= rngCooked[i]
            vec[i] = u
        }
    }

    fmt.Println("[")
    for i := 0; i < rngLen; i++ {
        fmt.Println(vec[i], ",")
    }
    fmt.Println("]")
}
```

> Now I get the array `vec` with `seed`=**`1337`**

Now, let's focus on the function `Uint64`.
We can see that it is doing the **array operation** at array `vec` with `feed` and `tag`, in which `vec[i]` is increased by `vec[(i + 273) % 607]` and the new value of `uint64(vec[i])` will return as a function result of the `Uint64`.

> We can now find that the full array will be changed after every 607 operation

Let the original value of `i` th in the array be `vi`, the array after `n` times operation be `vec`

> Here is the original array without any modify

| i   | 0   | 1   | ... | 605  | 606  |
|-----|-----|-----|-----|------|------|
| vi  | v0  | v1  | ... | v605 | v606 |

>After `607` times operation, the value will become:

| i   | 0    | ... | 333  | 334  | ... | 606  |
|-----|------|-----|------|------|-----|------|
|     |      |     |      | v546 |     |      |
|     | v546 |     |      | v273 |     | v545 |
|     | v273 |     | v606 | v0   |     | v272 |
|     | v0   | ... | v333 | v334 | ... | v606 |

> Actually, the above table is also the result of the first 607 operations, we define it **`v`** here

We can use this array to make a **matrix** called `mx` to represent the values, which are:

|     | v0  | ... | v272 | v273 | ... | v333 | v334 | ... | v545 | v546 | ... | v606 |
|-----|-----|-----|------|------|-----|------|------|-----|------|------|-----|------|
| 0   | 1   | ... | 0    | 1    | ... | 0    | 0    | ... | 0    | 1    | ... | 0    |
| ... | ... | ... | 0    | ...  | ... | ...  | ...  | ... | ...  | ...  | ... | ...  |
| 333 | 0   | ... | 0    | 0    | ... | 1    | 0    | ... | 0    | 0    | ... | 1    |
| 334 | 1   | ... | 0    | 1    | ... | 0    | 1    | ... | 0    | 1    | ... | 0    |
| ... | ... | ... | ...  | ...  | ... | ...  | ...  | ... | ...  | ...  | ... | ...  |
| 606 | 0   | ... | 1    | 0    | ... | 0    | 0    | ... | 1    | 0    | ... | 1    |

We can easily use `mx` dot `v` to make the result `vec` for n <= 607.
For `vec`, we can directly take `vec[n]` for the result of `n`th result of calling `Rand.Uint64()`.
Everything sounds great here.
We just need to multiply the matrix by itself, then we can get the result of the next **`607`** result of `rand.Uint64()`
The formula should be `mx^(roundup(n/607))`

>Seems now I can directly solve this question.

let me try to solve it with python. 

>`flag.py` by [`R1ckyH`](https://github.com/R1ckyH)
```python
import cupy as cu
v = cu.array([2519782774057415932 ,
    6302310259806978274 ,
     ...,
    5217656956907482849 ,
    -7913243967557714451
], dtype=cu.int64)


def init_vec():
    tap = 0 
    feed = 334 
    rngLen = 607 
    vec = [] 
    for i in range(607):
        vec.append(list([0] * 607))
        vec[i][i] = 1

    for i in range(607): 
        tap -= 1 
        if tap < 0: 
            tap += rngLen 
        feed -= 1 
        if feed < 0: 
            feed += rngLen 
        for j in range(607):
            vec[feed][j] += vec[tap][j]
    return vec

def find(n, mx):
    mx = cu.dot(cu.linalg.matrix_power(mx, round((n+303)/607)), v) # round up
    feed = (334 - n % 607) % 607
    return cu.uint8(cu.uint64(mx[feed].item()))

def main():
    import time
    start = time.time()
    with open("flag.enc", "rb") as f:
        flag = f.read()
    mx = cu.array(init_vec(), dtype=cu.int64)
    for i in range(64):
        n = (1 << i) + i + 2
        print(chr(flag[i] ^ find(n, mx)), end="")
    print(f"\ntime used{time.time() - start}s")


if __name__ == "__main__":
    main()

```

At the above code, I first get `v` by running the using go code above.
Then I pass it to python and use the python module to have a matrix operation.
I use the python module `cupy` to calculate the power of the matrix with **GPU acceleration**

Finally, I got the flag with **cpu**: `10750H` and **GPU** `RTX2060` 
>hkcert22{y0u_c4n_n4vig4t3_r4nd0mn3s5_f0rw4rds_and_b4ckw4rd5_n0w}
>
>time used**2.890268564224243s**
